# rusky Project Intelligence

## 프로젝트 컨텍스트
rusky는 Rust로 작성된 고성능 Git hooks 관리 도구로, husky의 대안을 목표로 합니다.

## 핵심 아키텍처 패턴

### 모듈 구조
```
src/
├── main.rs      # CLI 진입점, clap 기반 명령어 파싱
├── cli.rs       # 비즈니스 로직 구현, async 함수들
├── config.rs    # JSON 설정 관리, serde 활용
├── git.rs       # Git 명령어 래핑, tokio::process 사용
└── hooks.rs     # Hook 파일 생성/관리, 파일 권한 설정
```

### 중요한 기술적 결정
1. **비동기 I/O**: 모든 파일/프로세스 작업에 tokio 사용
2. **에러 처리**: anyhow로 에러 체인 단순화
3. **CLI**: clap derive 매크로로 타입 안전한 CLI
4. **설정**: JSON 형식으로 Node.js 생태계와 호환성 유지

## 성능 최적화 인사이트

### 달성한 성과
- 바이너리 크기: 1.7MB (목표 5MB 대비 66% 달성)
- 시작 시간: <1ms (목표 10ms 대비 1000% 달성)
- 메모리: ~1MB (목표 5MB 대비 500% 달성)

### 핵심 최적화 기법
- Release 빌드 사용으로 크기 최소화
- 비동기 I/O로 블로킹 최소화
- 최소한의 의존성으로 바이너리 크기 제어

## npm 통합 패턴

### 하이브리드 배포 전략
1. **install.js**: 플랫폼별 바이너리 다운로드 시도
2. **Fallback**: 실패 시 로컬 Rust 빌드
3. **크로스 플랫폼**: darwin/linux/win32 + x64/arm64 지원

### 중요한 파일들
- `package.json`: npm 메타데이터 + 플랫폼 제약
- `install.js`: 설치 로직 + 에러 처리
- `uninstall.js`: 정리 로직

## Git Hooks 메커니즘 이해

### Hook 파일 구조
```bash
#!/bin/sh
# Generated by rusky
set -e
echo "🐺 rusky > hook"
{command}
echo "✅ rusky > hook completed"
```

### 권한 관리
- Unix: chmod 755 (실행 권한)
- 설정 파일: 읽기/쓰기만
- Git 저장소 검증 필수

## 개발 워크플로우 패턴

### 테스트 전략
```bash
# 개발 중 빠른 테스트
cargo run -- init
cargo run -- add pre-commit "echo test"
git commit -m "test"  # hook 실행 확인
```

### 빌드 최적화
```bash
cargo build          # 개발용 (빠른 컴파일)
cargo build --release # 배포용 (크기 최적화)
```

## 사용자 경험 설계 원칙

### CLI 메시지 패턴
- 이모지 사용으로 친근함 증대 (🚀, ✅, 🐺)
- 색상 구분: 성공(녹색), 경고(노랑), 에러(빨강)
- 진행 상황 명확한 피드백

### 에러 처리 철학
- 사용자 친화적 메시지
- 해결 방법 제시
- Git 저장소 상태 검증

## 확장성 고려사항

### 미래 기능을 위한 준비
- `get_hook()`, `has_hooks()` 등 미사용 함수 유지
- 백업/복원 기능 준비
- 플러그인 시스템 고려한 구조

### 설정 확장 가능성
- YAML/TOML 지원 고려
- 환경별 설정 분리
- 조건부 실행 로직

## 배포 및 마케팅 전략

### 차별화 포인트
- "blazingly fast" - Rust 성능 강조
- "zero dependencies" - 런타임 의존성 없음
- "drop-in replacement" - husky 호환성

### 타겟 사용자
1. 성능에 민감한 개발자
2. 기존 husky 사용자 (마이그레이션)
3. Rust 생태계 관심자
4. CI/CD 최적화 필요한 팀

## 학습한 교훈

### Rust 개발
- async/await 패턴의 효과적 활용
- 에러 처리에서 anyhow의 편의성
- 모듈 분리를 통한 관심사 분리

### 오픈소스 프로젝트
- 명확한 README와 예제의 중요성
- 사용자 관점에서의 API 설계
- 성능 벤치마크의 마케팅 가치

### npm 생태계 통합
- Node.js 개발자 친화적 설치 경험
- 플랫폼별 바이너리 배포 복잡성
- Fallback 전략의 중요성

## 다음 개발 시 고려사항

1. **테스트 우선**: 자동화된 테스트 부족이 가장 큰 기술 부채
2. **Windows 테스트**: macOS/Linux 중심 개발로 Windows 검증 필요
3. **커뮤니티**: 혼자 개발의 한계, 기여자 확보 전략 필요
4. **성능 모니터링**: 실제 사용 환경에서의 성능 측정 필요

## 코딩 스타일 가이드

### Rust 관례 따르기
- snake_case for functions/variables
- PascalCase for types/structs
- 명시적 에러 처리 (Result<T> 활용)
- async/await 일관성 유지

### 프로젝트 특화 패턴
- CLI 함수는 모두 async
- 에러는 anyhow::Result로 통일
- 설정 관리는 Config 구조체 중심
- Git 작업은 Git 구조체로 추상화 