use anyhow::Result;
use std::os::unix::fs::PermissionsExt;
use tokio::fs;

use crate::git::Git;

pub struct HookManager;

impl HookManager {
    /// Hook 파일 생성
    pub async fn create_hook_file(hook_name: &str, command: &str) -> Result<()> {
        let hook_path = Git::get_hook_path(hook_name).await?;

        // Hook 스크립트 내용 생성
        let hook_content = Self::generate_hook_script(command);

        // Hook 파일 작성
        fs::write(&hook_path, hook_content).await?;

        // 실행 권한 부여
        let mut perms = fs::metadata(&hook_path).await?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&hook_path, perms).await?;

        Ok(())
    }

    /// Hook 파일 삭제
    pub async fn remove_hook_file(hook_name: &str) -> Result<()> {
        let hook_path = Git::get_hook_path(hook_name).await?;

        if hook_path.exists() {
            fs::remove_file(&hook_path).await?;
        }

        Ok(())
    }

    /// Hook 스크립트 생성
    fn generate_hook_script(command: &str) -> String {
        format!(
            r#"#!/bin/sh
# Generated by rusky

set -e

echo "🐺 rusky > {hook_name}"

# Execute the command
{command}

echo "✅ rusky > {hook_name} completed"
"#,
            hook_name = "hook",
            command = command
        )
    }

    /// 모든 Hook 파일 백업
    #[allow(dead_code)]
    pub async fn backup_existing_hooks() -> Result<()> {
        let hooks_dir = Git::get_hooks_dir().await?;
        let backup_dir = hooks_dir.join("rusky_backup");

        if !backup_dir.exists() {
            fs::create_dir(&backup_dir).await?;
        }

        // 기존 hook 파일들을 백업
        let mut entries = fs::read_dir(&hooks_dir).await?;
        while let Some(entry) = entries.next_entry().await? {
            let path = entry.path();
            if path.is_file()
                && !path
                    .file_name()
                    .unwrap()
                    .to_str()
                    .unwrap()
                    .starts_with("rusky_backup")
            {
                let file_name = path.file_name().unwrap();
                let backup_path = backup_dir.join(file_name);
                fs::copy(&path, &backup_path).await?;
            }
        }

        Ok(())
    }

    /// 백업된 Hook 파일 복원
    #[allow(dead_code)]
    pub async fn restore_hooks() -> Result<()> {
        let hooks_dir = Git::get_hooks_dir().await?;
        let backup_dir = hooks_dir.join("rusky_backup");

        if !backup_dir.exists() {
            return Ok(());
        }

        let mut entries = fs::read_dir(&backup_dir).await?;
        while let Some(entry) = entries.next_entry().await? {
            let path = entry.path();
            if path.is_file() {
                let file_name = path.file_name().unwrap();
                let restore_path = hooks_dir.join(file_name);
                fs::copy(&path, &restore_path).await?;
            }
        }

        // 백업 디렉토리 삭제
        fs::remove_dir_all(&backup_dir).await?;

        Ok(())
    }

    /// Hook 파일이 rusky에 의해 관리되는지 확인
    #[allow(dead_code)]
    pub async fn is_rusky_hook(hook_name: &str) -> Result<bool> {
        let hook_path = Git::get_hook_path(hook_name).await?;

        if !hook_path.exists() {
            return Ok(false);
        }

        let content = fs::read_to_string(&hook_path).await?;
        Ok(content.contains("Generated by rusky"))
    }
}
