use anyhow::Result;
use std::os::unix::fs::PermissionsExt;
use tokio::fs;

use crate::git::Git;

pub struct HookManager;

impl HookManager {
    /// Hook íŒŒì¼ ìƒì„±
    pub async fn create_hook_file(hook_name: &str, command: &str) -> Result<()> {
        let hook_path = Git::get_hook_path(hook_name).await?;

        // Hook ìŠ¤í¬ë¦½íŠ¸ ë‚´ìš© ìƒì„±
        let hook_content = Self::generate_hook_script(command);

        // Hook íŒŒì¼ ìž‘ì„±
        fs::write(&hook_path, hook_content).await?;

        // ì‹¤í–‰ ê¶Œí•œ ë¶€ì—¬
        let mut perms = fs::metadata(&hook_path).await?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&hook_path, perms).await?;

        Ok(())
    }

    /// Hook íŒŒì¼ ì‚­ì œ
    pub async fn remove_hook_file(hook_name: &str) -> Result<()> {
        let hook_path = Git::get_hook_path(hook_name).await?;

        if hook_path.exists() {
            fs::remove_file(&hook_path).await?;
        }

        Ok(())
    }

    /// Hook ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
    fn generate_hook_script(command: &str) -> String {
        format!(
            r#"#!/bin/sh
# Generated by rusky

set -e

echo "ðŸº rusky > {hook_name}"

# Execute the command
{command}

echo "âœ… rusky > {hook_name} completed"
"#,
            hook_name = "hook",
            command = command
        )
    }

    /// ëª¨ë“  Hook íŒŒì¼ ë°±ì—…
    #[allow(dead_code)]
    pub async fn backup_existing_hooks() -> Result<()> {
        let hooks_dir = Git::get_hooks_dir().await?;
        let backup_dir = hooks_dir.join("rusky_backup");

        if !backup_dir.exists() {
            fs::create_dir(&backup_dir).await?;
        }

        // ê¸°ì¡´ hook íŒŒì¼ë“¤ì„ ë°±ì—…
        let mut entries = fs::read_dir(&hooks_dir).await?;
        while let Some(entry) = entries.next_entry().await? {
            let path = entry.path();
            if path.is_file()
                && !path
                    .file_name()
                    .unwrap()
                    .to_str()
                    .unwrap()
                    .starts_with("rusky_backup")
            {
                let file_name = path.file_name().unwrap();
                let backup_path = backup_dir.join(file_name);
                fs::copy(&path, &backup_path).await?;
            }
        }

        Ok(())
    }

    /// ë°±ì—…ëœ Hook íŒŒì¼ ë³µì›
    #[allow(dead_code)]
    pub async fn restore_hooks() -> Result<()> {
        let hooks_dir = Git::get_hooks_dir().await?;
        let backup_dir = hooks_dir.join("rusky_backup");

        if !backup_dir.exists() {
            return Ok(());
        }

        let mut entries = fs::read_dir(&backup_dir).await?;
        while let Some(entry) = entries.next_entry().await? {
            let path = entry.path();
            if path.is_file() {
                let file_name = path.file_name().unwrap();
                let restore_path = hooks_dir.join(file_name);
                fs::copy(&path, &restore_path).await?;
            }
        }

        // ë°±ì—… ë””ë ‰í† ë¦¬ ì‚­ì œ
        fs::remove_dir_all(&backup_dir).await?;

        Ok(())
    }

    /// Hook íŒŒì¼ì´ ruskyì— ì˜í•´ ê´€ë¦¬ë˜ëŠ”ì§€ í™•ì¸
    #[allow(dead_code)]
    pub async fn is_rusky_hook(hook_name: &str) -> Result<bool> {
        let hook_path = Git::get_hook_path(hook_name).await?;

        if !hook_path.exists() {
            return Ok(false);
        }

        let content = fs::read_to_string(&hook_path).await?;
        Ok(content.contains("Generated by rusky"))
    }
}
