use anyhow::Result;
use std::os::unix::fs::PermissionsExt;
use tokio::fs;

use crate::git::Git;

pub struct HookManager;

impl HookManager {
    /// Hook 파일 생성
    pub async fn create_hook_file(hook_name: &str, command: &str) -> Result<()> {
        let hook_path = Git::get_hook_path(hook_name).await?;

        // Hook 스크립트 내용 생성
        let hook_content = Self::generate_hook_script(command);

        // Hook 파일 작성
        fs::write(&hook_path, hook_content).await?;

        // 실행 권한 부여
        let mut perms = fs::metadata(&hook_path).await?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&hook_path, perms).await?;

        Ok(())
    }

    /// Hook 파일 삭제
    pub async fn remove_hook_file(hook_name: &str) -> Result<()> {
        let hook_path = Git::get_hook_path(hook_name).await?;

        if hook_path.exists() {
            fs::remove_file(&hook_path).await?;
        }

        Ok(())
    }

    /// Hook 스크립트 생성
    fn generate_hook_script(command: &str) -> String {
        format!(
            r#"#!/bin/sh
# Generated by rusky

set -e

echo "🐺 rusky > {hook_name}"

# Execute the command
{command}

echo "✅ rusky > {hook_name} completed"
"#,
            hook_name = "hook",
            command = command
        )
    }

    /// 모든 Hook 파일 백업
    #[allow(dead_code)]
    pub async fn backup_existing_hooks() -> Result<()> {
        let hooks_dir = Git::get_hooks_dir().await?;
        let backup_dir = hooks_dir.join("rusky_backup");

        if !backup_dir.exists() {
            fs::create_dir(&backup_dir).await?;
        }

        // 기존 hook 파일들을 백업
        let mut entries = fs::read_dir(&hooks_dir).await?;
        while let Some(entry) = entries.next_entry().await? {
            let path = entry.path();
            if path.is_file()
                && !path
                    .file_name()
                    .unwrap()
                    .to_str()
                    .unwrap()
                    .starts_with("rusky_backup")
            {
                let file_name = path.file_name().unwrap();
                let backup_path = backup_dir.join(file_name);
                fs::copy(&path, &backup_path).await?;
            }
        }

        Ok(())
    }

    /// 백업된 Hook 파일 복원
    #[allow(dead_code)]
    pub async fn restore_hooks() -> Result<()> {
        let hooks_dir = Git::get_hooks_dir().await?;
        let backup_dir = hooks_dir.join("rusky_backup");

        if !backup_dir.exists() {
            return Ok(());
        }

        let mut entries = fs::read_dir(&backup_dir).await?;
        while let Some(entry) = entries.next_entry().await? {
            let path = entry.path();
            if path.is_file() {
                let file_name = path.file_name().unwrap();
                let restore_path = hooks_dir.join(file_name);
                fs::copy(&path, &restore_path).await?;
            }
        }

        // 백업 디렉토리 삭제
        fs::remove_dir_all(&backup_dir).await?;

        Ok(())
    }

    /// Hook 파일이 rusky에 의해 관리되는지 확인
    #[allow(dead_code)]
    pub async fn is_rusky_hook(hook_name: &str) -> Result<bool> {
        let hook_path = Git::get_hook_path(hook_name).await?;

        if !hook_path.exists() {
            return Ok(false);
        }

        let content = fs::read_to_string(&hook_path).await?;
        Ok(content.contains("Generated by rusky"))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    use std::env;
    use std::os::unix::fs::PermissionsExt;

    #[tokio::test]
    async fn test_generate_hook_script() {
        let script = HookManager::generate_hook_script("echo 'test'");
        
        assert!(script.contains("#!/bin/sh"));
        assert!(script.contains("Generated by rusky"));
        assert!(script.contains("set -e"));
        assert!(script.contains("echo 'test'"));
        assert!(script.contains("🐺 rusky > hook"));
        assert!(script.contains("✅ rusky > hook completed"));
    }

    #[tokio::test]
    async fn test_create_and_remove_hook_file() {
        let temp_dir = TempDir::new().unwrap();
        let original_dir = env::current_dir().unwrap();
        
        // 임시 Git 저장소 설정
        env::set_current_dir(temp_dir.path()).unwrap();
        tokio::process::Command::new("git")
            .args(&["init"])
            .output()
            .await
            .unwrap();
        
        // Hook 파일 생성
        let result = HookManager::create_hook_file("pre-commit", "echo 'test hook'").await;
        assert!(result.is_ok());
        
        // Hook 파일 존재 확인
        let hook_path = Git::get_hook_path("pre-commit").await.unwrap();
        assert!(hook_path.exists());
        
        // 실행 권한 확인
        let metadata = tokio::fs::metadata(&hook_path).await.unwrap();
        let permissions = metadata.permissions();
        assert_eq!(permissions.mode() & 0o777, 0o755);
        
        // Hook 파일 내용 확인
        let content = tokio::fs::read_to_string(&hook_path).await.unwrap();
        assert!(content.contains("Generated by rusky"));
        assert!(content.contains("echo 'test hook'"));
        
        // Hook 파일 삭제
        let result = HookManager::remove_hook_file("pre-commit").await;
        assert!(result.is_ok());
        assert!(!hook_path.exists());
        
        // 원래 디렉토리로 복원
        env::set_current_dir(original_dir).unwrap();
    }

    #[tokio::test]
    async fn test_remove_nonexistent_hook_file() {
        let temp_dir = TempDir::new().unwrap();
        let original_dir = env::current_dir().unwrap();
        
        // 임시 Git 저장소 설정
        env::set_current_dir(temp_dir.path()).unwrap();
        tokio::process::Command::new("git")
            .args(&["init"])
            .output()
            .await
            .unwrap();
        
        // 존재하지 않는 Hook 파일 삭제 시도 (에러가 발생하지 않아야 함)
        let result = HookManager::remove_hook_file("non-existent").await;
        assert!(result.is_ok());
        
        // 원래 디렉토리로 복원
        env::set_current_dir(original_dir).unwrap();
    }

    #[tokio::test]
    async fn test_is_rusky_hook() {
        let temp_dir = TempDir::new().unwrap();
        let original_dir = env::current_dir().unwrap();
        
        // 임시 Git 저장소 설정
        env::set_current_dir(temp_dir.path()).unwrap();
        tokio::process::Command::new("git")
            .args(&["init"])
            .output()
            .await
            .unwrap();
        
        // rusky hook 생성
        HookManager::create_hook_file("pre-commit", "echo 'test'").await.unwrap();
        let is_rusky = HookManager::is_rusky_hook("pre-commit").await.unwrap();
        assert!(is_rusky);
        
        // 수동으로 다른 hook 파일 생성
        let hook_path = Git::get_hook_path("pre-push").await.unwrap();
        tokio::fs::write(&hook_path, "#!/bin/sh\necho 'manual hook'").await.unwrap();
        let is_rusky = HookManager::is_rusky_hook("pre-push").await.unwrap();
        assert!(!is_rusky);
        
        // 존재하지 않는 hook
        let is_rusky = HookManager::is_rusky_hook("non-existent").await.unwrap();
        assert!(!is_rusky);
        
        // 원래 디렉토리로 복원
        env::set_current_dir(original_dir).unwrap();
    }
}
