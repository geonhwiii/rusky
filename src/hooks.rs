use anyhow::Result;
use std::os::unix::fs::PermissionsExt;
use tokio::fs;

use crate::git::Git;

pub struct HookManager;

impl HookManager {
    /// Hook íŒŒì¼ ìƒì„±
    pub async fn create_hook_file(hook_name: &str, command: &str) -> Result<()> {
        let hook_path = Git::get_hook_path(hook_name).await?;

        // Hook ìŠ¤í¬ë¦½íŠ¸ ë‚´ìš© ìƒì„±
        let hook_content = Self::generate_hook_script(command);

        // Hook íŒŒì¼ ì‘ì„±
        fs::write(&hook_path, hook_content).await?;

        // ì‹¤í–‰ ê¶Œí•œ ë¶€ì—¬
        let mut perms = fs::metadata(&hook_path).await?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&hook_path, perms).await?;

        Ok(())
    }

    /// Hook íŒŒì¼ ì‚­ì œ
    pub async fn remove_hook_file(hook_name: &str) -> Result<()> {
        let hook_path = Git::get_hook_path(hook_name).await?;

        if hook_path.exists() {
            fs::remove_file(&hook_path).await?;
        }

        Ok(())
    }

    /// Hook ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
    fn generate_hook_script(command: &str) -> String {
        format!(
            r#"#!/bin/sh
# Generated by rusky

set -e

echo "ğŸº rusky > {hook_name}"

# Execute the command
{command}

echo "âœ… rusky > {hook_name} completed"
"#,
            hook_name = "hook",
            command = command
        )
    }

    /// ëª¨ë“  Hook íŒŒì¼ ë°±ì—…
    #[allow(dead_code)]
    pub async fn backup_existing_hooks() -> Result<()> {
        let hooks_dir = Git::get_hooks_dir().await?;
        let backup_dir = hooks_dir.join("rusky_backup");

        if !backup_dir.exists() {
            fs::create_dir(&backup_dir).await?;
        }

        // ê¸°ì¡´ hook íŒŒì¼ë“¤ì„ ë°±ì—…
        let mut entries = fs::read_dir(&hooks_dir).await?;
        while let Some(entry) = entries.next_entry().await? {
            let path = entry.path();
            if path.is_file()
                && !path
                    .file_name()
                    .unwrap()
                    .to_str()
                    .unwrap()
                    .starts_with("rusky_backup")
            {
                let file_name = path.file_name().unwrap();
                let backup_path = backup_dir.join(file_name);
                fs::copy(&path, &backup_path).await?;
            }
        }

        Ok(())
    }

    /// ë°±ì—…ëœ Hook íŒŒì¼ ë³µì›
    #[allow(dead_code)]
    pub async fn restore_hooks() -> Result<()> {
        let hooks_dir = Git::get_hooks_dir().await?;
        let backup_dir = hooks_dir.join("rusky_backup");

        if !backup_dir.exists() {
            return Ok(());
        }

        let mut entries = fs::read_dir(&backup_dir).await?;
        while let Some(entry) = entries.next_entry().await? {
            let path = entry.path();
            if path.is_file() {
                let file_name = path.file_name().unwrap();
                let restore_path = hooks_dir.join(file_name);
                fs::copy(&path, &restore_path).await?;
            }
        }

        // ë°±ì—… ë””ë ‰í† ë¦¬ ì‚­ì œ
        fs::remove_dir_all(&backup_dir).await?;

        Ok(())
    }

    /// Hook íŒŒì¼ì´ ruskyì— ì˜í•´ ê´€ë¦¬ë˜ëŠ”ì§€ í™•ì¸
    #[allow(dead_code)]
    pub async fn is_rusky_hook(hook_name: &str) -> Result<bool> {
        let hook_path = Git::get_hook_path(hook_name).await?;

        if !hook_path.exists() {
            return Ok(false);
        }

        let content = fs::read_to_string(&hook_path).await?;
        Ok(content.contains("Generated by rusky"))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    use std::env;
    use std::os::unix::fs::PermissionsExt;

    #[tokio::test]
    async fn test_generate_hook_script() {
        let script = HookManager::generate_hook_script("echo 'test'");
        
        assert!(script.contains("#!/bin/sh"));
        assert!(script.contains("Generated by rusky"));
        assert!(script.contains("set -e"));
        assert!(script.contains("echo 'test'"));
        assert!(script.contains("ğŸº rusky > hook"));
        assert!(script.contains("âœ… rusky > hook completed"));
    }

    #[tokio::test]
    async fn test_create_and_remove_hook_file() {
        let temp_dir = TempDir::new().unwrap();
        let original_dir = env::current_dir().unwrap();
        
        // ì„ì‹œ Git ì €ì¥ì†Œ ì„¤ì •
        env::set_current_dir(temp_dir.path()).unwrap();
        tokio::process::Command::new("git")
            .args(&["init"])
            .output()
            .await
            .unwrap();
        
        // Hook íŒŒì¼ ìƒì„±
        let result = HookManager::create_hook_file("pre-commit", "echo 'test hook'").await;
        assert!(result.is_ok());
        
        // Hook íŒŒì¼ ì¡´ì¬ í™•ì¸
        let hook_path = Git::get_hook_path("pre-commit").await.unwrap();
        assert!(hook_path.exists());
        
        // ì‹¤í–‰ ê¶Œí•œ í™•ì¸
        let metadata = tokio::fs::metadata(&hook_path).await.unwrap();
        let permissions = metadata.permissions();
        assert_eq!(permissions.mode() & 0o777, 0o755);
        
        // Hook íŒŒì¼ ë‚´ìš© í™•ì¸
        let content = tokio::fs::read_to_string(&hook_path).await.unwrap();
        assert!(content.contains("Generated by rusky"));
        assert!(content.contains("echo 'test hook'"));
        
        // Hook íŒŒì¼ ì‚­ì œ
        let result = HookManager::remove_hook_file("pre-commit").await;
        assert!(result.is_ok());
        assert!(!hook_path.exists());
        
        // ì›ë˜ ë””ë ‰í† ë¦¬ë¡œ ë³µì›
        env::set_current_dir(original_dir).unwrap();
    }

    #[tokio::test]
    async fn test_remove_nonexistent_hook_file() {
        let temp_dir = TempDir::new().unwrap();
        let original_dir = env::current_dir().unwrap();
        
        // ì„ì‹œ Git ì €ì¥ì†Œ ì„¤ì •
        env::set_current_dir(temp_dir.path()).unwrap();
        tokio::process::Command::new("git")
            .args(&["init"])
            .output()
            .await
            .unwrap();
        
        // ì¡´ì¬í•˜ì§€ ì•ŠëŠ” Hook íŒŒì¼ ì‚­ì œ ì‹œë„ (ì—ëŸ¬ê°€ ë°œìƒí•˜ì§€ ì•Šì•„ì•¼ í•¨)
        let result = HookManager::remove_hook_file("non-existent").await;
        assert!(result.is_ok());
        
        // ì›ë˜ ë””ë ‰í† ë¦¬ë¡œ ë³µì›
        env::set_current_dir(original_dir).unwrap();
    }

    #[tokio::test]
    async fn test_is_rusky_hook() {
        let temp_dir = TempDir::new().unwrap();
        let original_dir = env::current_dir().unwrap();
        
        // ì„ì‹œ Git ì €ì¥ì†Œ ì„¤ì •
        env::set_current_dir(temp_dir.path()).unwrap();
        tokio::process::Command::new("git")
            .args(&["init"])
            .output()
            .await
            .unwrap();
        
        // rusky hook ìƒì„±
        HookManager::create_hook_file("pre-commit", "echo 'test'").await.unwrap();
        let is_rusky = HookManager::is_rusky_hook("pre-commit").await.unwrap();
        assert!(is_rusky);
        
        // ìˆ˜ë™ìœ¼ë¡œ ë‹¤ë¥¸ hook íŒŒì¼ ìƒì„±
        let hook_path = Git::get_hook_path("pre-push").await.unwrap();
        tokio::fs::write(&hook_path, "#!/bin/sh\necho 'manual hook'").await.unwrap();
        let is_rusky = HookManager::is_rusky_hook("pre-push").await.unwrap();
        assert!(!is_rusky);
        
        // ì¡´ì¬í•˜ì§€ ì•ŠëŠ” hook
        let is_rusky = HookManager::is_rusky_hook("non-existent").await.unwrap();
        assert!(!is_rusky);
        
        // ì›ë˜ ë””ë ‰í† ë¦¬ë¡œ ë³µì›
        env::set_current_dir(original_dir).unwrap();
    }
}
